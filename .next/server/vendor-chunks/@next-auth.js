"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@next-auth";
exports.ids = ["vendor-chunks/@next-auth"];
exports.modules = {

/***/ "(rsc)/./node_modules/@next-auth/dynamodb-adapter/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@next-auth/dynamodb-adapter/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DynamoDBAdapter: () => (/* binding */ DynamoDBAdapter),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   generateUpdateExpression: () => (/* binding */ generateUpdateExpression)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/**\n * <div style={{display: \"flex\", justifyContent: \"space-between\", alignItems: \"center\", padding: 16}}>\n *  <p style={{fontWeight: \"normal\"}}>Official <a href=\"https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html\">DynamoDB</a> adapter for Auth.js / NextAuth.js.</p>\n *  <a href=\"https://docs.aws.amazon.com/dynamodb/index.html\">\n *   <img style={{display: \"block\"}} src=\"https://authjs.dev/img/adapters/dynamodb.png\" width=\"48\"/>\n *  </a>\n * </div>\n *\n * ## Installation\n *\n * ```bash npm2yarn2pnpm\n * npm install next-auth @next-auth/dynamodb-adapter\n * ```\n *\n * @module @next-auth/dynamodb-adapter\n */\n\n/**\n * ## Setup\n *\n * By default, the adapter expects a table with a partition key `pk` and a sort key `sk`, as well as a global secondary index named `GSI1` with `GSI1PK` as partition key and `GSI1SK` as sorting key. To automatically delete sessions and verification requests after they expire using [dynamodb TTL](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html) you should [enable the TTL](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/time-to-live-ttl-how-to.html) with attribute name 'expires'. You can set whatever you want as the table name and the billing method.\n * You can find the full schema in the table structure section below.\n *\n * ### Configuring Auth.js\n *\n * You need to pass `DynamoDBDocument` client from the modular [`aws-sdk`](https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/dynamodb-example-dynamodb-utilities.html) v3 to the adapter.\n * The default table name is `next-auth`, but you can customise that by passing `{ tableName: 'your-table-name' }` as the second parameter in the adapter.\n *\n * ```javascript title=\"pages/api/auth/[...nextauth].js\"\n * import { DynamoDB, DynamoDBClientConfig } from \"@aws-sdk/client-dynamodb\"\n * import { DynamoDBDocument } from \"@aws-sdk/lib-dynamodb\"\n * import NextAuth from \"next-auth\";\n * import Providers from \"next-auth/providers\";\n * import { DynamoDBAdapter } from \"@next-auth/dynamodb-adapter\"\n *\n * const config: DynamoDBClientConfig = {\n *   credentials: {\n *     accessKeyId: process.env.NEXT_AUTH_AWS_ACCESS_KEY as string,\n *     secretAccessKey: process.env.NEXT_AUTH_AWS_SECRET_KEY as string,\n *   },\n *   region: process.env.NEXT_AUTH_AWS_REGION,\n * };\n *\n * const client = DynamoDBDocument.from(new DynamoDB(config), {\n *   marshallOptions: {\n *     convertEmptyValues: true,\n *     removeUndefinedValues: true,\n *     convertClassInstanceToMap: true,\n *   },\n * })\n *\n * export default NextAuth({\n *   // Configure one or more authentication providers\n *   providers: [\n *     Providers.GitHub({\n *       clientId: process.env.GITHUB_ID,\n *       clientSecret: process.env.GITHUB_SECRET,\n *     }),\n *     Providers.Email({\n *       server: process.env.EMAIL_SERVER,\n *       from: process.env.EMAIL_FROM,\n *     }),\n *     // ...add more providers here\n *   ],\n *   adapter: DynamoDBAdapter(\n *     client\n *   ),\n *   ...\n * });\n * ```\n *\n * (AWS secrets start with `NEXT_AUTH_` in order to not conflict with [Vercel's reserved environment variables](https://vercel.com/docs/environment-variables#reserved-environment-variables).)\n *\n * ## Advanced usage\n *\n * ### Default schema\n *\n * The table respects the single table design pattern. This has many advantages:\n *\n * - Only one table to manage, monitor and provision.\n * - Querying relations is faster than with multi-table schemas (for eg. retrieving all sessions for a user).\n * - Only one table needs to be replicated if you want to go multi-region.\n *\n * > This schema is adapted for use in DynamoDB and based upon our main [schema](https://authjs.dev/reference/adapters#models)\n *\n * ![DynamoDB Table](https://i.imgur.com/hGZtWDq.png)\n *\n * You can create this table with infrastructure as code using [`aws-cdk`](https://github.com/aws/aws-cdk) with the following table definition:\n *\n * ```javascript title=stack.ts\n * new dynamodb.Table(this, `NextAuthTable`, {\n *   tableName: \"next-auth\",\n *   partitionKey: { name: \"pk\", type: dynamodb.AttributeType.STRING },\n *   sortKey: { name: \"sk\", type: dynamodb.AttributeType.STRING },\n *   timeToLiveAttribute: \"expires\",\n * }).addGlobalSecondaryIndex({\n *   indexName: \"GSI1\",\n *   partitionKey: { name: \"GSI1PK\", type: dynamodb.AttributeType.STRING },\n *   sortKey: { name: \"GSI1SK\", type: dynamodb.AttributeType.STRING },\n * })\n * ```\n *\n * Alternatively, you can use this cloudformation template:\n *\n * ```yaml title=cloudformation.yaml\n * NextAuthTable:\n *   Type: \"AWS::DynamoDB::Table\"\n *   Properties:\n *     TableName: next-auth\n *     AttributeDefinitions:\n *       - AttributeName: pk\n *         AttributeType: S\n *       - AttributeName: sk\n *         AttributeType: S\n *       - AttributeName: GSI1PK\n *         AttributeType: S\n *       - AttributeName: GSI1SK\n *         AttributeType: S\n *     KeySchema:\n *       - AttributeName: pk\n *         KeyType: HASH\n *       - AttributeName: sk\n *         KeyType: RANGE\n *     GlobalSecondaryIndexes:\n *       - IndexName: GSI1\n *         Projection:\n *           ProjectionType: ALL\n *         KeySchema:\n *           - AttributeName: GSI1PK\n *             KeyType: HASH\n *           - AttributeName: GSI1SK\n *             KeyType: RANGE\n *     TimeToLiveSpecification:\n *       AttributeName: expires\n *       Enabled: true\n * ```\n *\n * ### Using a custom schema\n *\n * You can configure your custom table schema by passing the `options` key to the adapter constructor:\n *\n * ```javascript\n * const adapter = DynamoDBAdapter(client, {\n *   tableName: \"custom-table-name\",\n *   partitionKey: \"custom-pk\",\n *   sortKey: \"custom-sk\",\n *   indexName: \"custom-index-name\",\n *   indexPartitionKey: \"custom-index-pk\",\n *   indexSortKey: \"custom-index-sk\",\n * })\n * ```\n **/\nfunction DynamoDBAdapter(client, options) {\n    const TableName = options?.tableName ?? \"next-auth\";\n    const pk = options?.partitionKey ?? \"pk\";\n    const sk = options?.sortKey ?? \"sk\";\n    const IndexName = options?.indexName ?? \"GSI1\";\n    const GSI1PK = options?.indexPartitionKey ?? \"GSI1PK\";\n    const GSI1SK = options?.indexSortKey ?? \"GSI1SK\";\n    return {\n        async createUser(data) {\n            const user = {\n                ...data,\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n            };\n            await client.put({\n                TableName,\n                Item: format.to({\n                    ...user,\n                    [pk]: `USER#${user.id}`,\n                    [sk]: `USER#${user.id}`,\n                    type: \"USER\",\n                    [GSI1PK]: `USER#${user.email}`,\n                    [GSI1SK]: `USER#${user.email}`,\n                }),\n            });\n            return user;\n        },\n        async getUser(userId) {\n            const data = await client.get({\n                TableName,\n                Key: {\n                    [pk]: `USER#${userId}`,\n                    [sk]: `USER#${userId}`,\n                },\n            });\n            return format.from(data.Item);\n        },\n        async getUserByEmail(email) {\n            const data = await client.query({\n                TableName,\n                IndexName,\n                KeyConditionExpression: \"#gsi1pk = :gsi1pk AND #gsi1sk = :gsi1sk\",\n                ExpressionAttributeNames: {\n                    \"#gsi1pk\": GSI1PK,\n                    \"#gsi1sk\": GSI1SK,\n                },\n                ExpressionAttributeValues: {\n                    \":gsi1pk\": `USER#${email}`,\n                    \":gsi1sk\": `USER#${email}`,\n                },\n            });\n            return format.from(data.Items?.[0]);\n        },\n        async getUserByAccount({ provider, providerAccountId }) {\n            const data = await client.query({\n                TableName,\n                IndexName,\n                KeyConditionExpression: \"#gsi1pk = :gsi1pk AND #gsi1sk = :gsi1sk\",\n                ExpressionAttributeNames: {\n                    \"#gsi1pk\": GSI1PK,\n                    \"#gsi1sk\": GSI1SK,\n                },\n                ExpressionAttributeValues: {\n                    \":gsi1pk\": `ACCOUNT#${provider}`,\n                    \":gsi1sk\": `ACCOUNT#${providerAccountId}`,\n                },\n            });\n            if (!data.Items?.length)\n                return null;\n            const accounts = data.Items[0];\n            const res = await client.get({\n                TableName,\n                Key: {\n                    [pk]: `USER#${accounts.userId}`,\n                    [sk]: `USER#${accounts.userId}`,\n                },\n            });\n            return format.from(res.Item);\n        },\n        async updateUser(user) {\n            const { UpdateExpression, ExpressionAttributeNames, ExpressionAttributeValues, } = generateUpdateExpression(user);\n            const data = await client.update({\n                TableName,\n                Key: {\n                    // next-auth type is incorrect it should be Partial<AdapterUser> & {id: string} instead of just Partial<AdapterUser>\n                    [pk]: `USER#${user.id}`,\n                    [sk]: `USER#${user.id}`,\n                },\n                UpdateExpression,\n                ExpressionAttributeNames,\n                ExpressionAttributeValues,\n                ReturnValues: \"ALL_NEW\",\n            });\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return format.from(data.Attributes);\n        },\n        async deleteUser(userId) {\n            // query all the items related to the user to delete\n            const res = await client.query({\n                TableName,\n                KeyConditionExpression: \"#pk = :pk\",\n                ExpressionAttributeNames: { \"#pk\": pk },\n                ExpressionAttributeValues: { \":pk\": `USER#${userId}` },\n            });\n            if (!res.Items)\n                return null;\n            const items = res.Items;\n            // find the user we want to delete to return at the end of the function call\n            const user = items.find((item) => item.type === \"USER\");\n            const itemsToDelete = items.map((item) => {\n                return {\n                    DeleteRequest: {\n                        Key: {\n                            [sk]: item.sk,\n                            [pk]: item.pk,\n                        },\n                    },\n                };\n            });\n            // batch write commands cannot handle more than 25 requests at once\n            const itemsToDeleteMax = itemsToDelete.slice(0, 25);\n            const param = {\n                RequestItems: { [TableName]: itemsToDeleteMax },\n            };\n            await client.batchWrite(param);\n            return format.from(user);\n        },\n        async linkAccount(data) {\n            const item = {\n                ...data,\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n                [pk]: `USER#${data.userId}`,\n                [sk]: `ACCOUNT#${data.provider}#${data.providerAccountId}`,\n                [GSI1PK]: `ACCOUNT#${data.provider}`,\n                [GSI1SK]: `ACCOUNT#${data.providerAccountId}`,\n            };\n            await client.put({ TableName, Item: format.to(item) });\n            return data;\n        },\n        async unlinkAccount({ provider, providerAccountId }) {\n            const data = await client.query({\n                TableName,\n                IndexName,\n                KeyConditionExpression: \"#gsi1pk = :gsi1pk AND #gsi1sk = :gsi1sk\",\n                ExpressionAttributeNames: {\n                    \"#gsi1pk\": GSI1PK,\n                    \"#gsi1sk\": GSI1SK,\n                },\n                ExpressionAttributeValues: {\n                    \":gsi1pk\": `ACCOUNT#${provider}`,\n                    \":gsi1sk\": `ACCOUNT#${providerAccountId}`,\n                },\n            });\n            const account = format.from(data.Items?.[0]);\n            if (!account)\n                return;\n            await client.delete({\n                TableName,\n                Key: {\n                    [pk]: `USER#${account.userId}`,\n                    [sk]: `ACCOUNT#${provider}#${providerAccountId}`,\n                },\n                ReturnValues: \"ALL_OLD\",\n            });\n            return account;\n        },\n        async getSessionAndUser(sessionToken) {\n            const data = await client.query({\n                TableName,\n                IndexName,\n                KeyConditionExpression: \"#gsi1pk = :gsi1pk AND #gsi1sk = :gsi1sk\",\n                ExpressionAttributeNames: {\n                    \"#gsi1pk\": GSI1PK,\n                    \"#gsi1sk\": GSI1SK,\n                },\n                ExpressionAttributeValues: {\n                    \":gsi1pk\": `SESSION#${sessionToken}`,\n                    \":gsi1sk\": `SESSION#${sessionToken}`,\n                },\n            });\n            const session = format.from(data.Items?.[0]);\n            if (!session)\n                return null;\n            const res = await client.get({\n                TableName,\n                Key: {\n                    [pk]: `USER#${session.userId}`,\n                    [sk]: `USER#${session.userId}`,\n                },\n            });\n            const user = format.from(res.Item);\n            if (!user)\n                return null;\n            return { user, session };\n        },\n        async createSession(data) {\n            const session = {\n                id: (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n                ...data,\n            };\n            await client.put({\n                TableName,\n                Item: format.to({\n                    [pk]: `USER#${data.userId}`,\n                    [sk]: `SESSION#${data.sessionToken}`,\n                    [GSI1SK]: `SESSION#${data.sessionToken}`,\n                    [GSI1PK]: `SESSION#${data.sessionToken}`,\n                    type: \"SESSION\",\n                    ...data,\n                }),\n            });\n            return session;\n        },\n        async updateSession(session) {\n            const { sessionToken } = session;\n            const data = await client.query({\n                TableName,\n                IndexName,\n                KeyConditionExpression: \"#gsi1pk = :gsi1pk AND #gsi1sk = :gsi1sk\",\n                ExpressionAttributeNames: {\n                    \"#gsi1pk\": GSI1PK,\n                    \"#gsi1sk\": GSI1SK,\n                },\n                ExpressionAttributeValues: {\n                    \":gsi1pk\": `SESSION#${sessionToken}`,\n                    \":gsi1sk\": `SESSION#${sessionToken}`,\n                },\n            });\n            if (!data.Items?.length)\n                return null;\n            const { pk, sk } = data.Items[0];\n            const { UpdateExpression, ExpressionAttributeNames, ExpressionAttributeValues, } = generateUpdateExpression(session);\n            const res = await client.update({\n                TableName,\n                Key: { pk, sk },\n                UpdateExpression,\n                ExpressionAttributeNames,\n                ExpressionAttributeValues,\n                ReturnValues: \"ALL_NEW\",\n            });\n            return format.from(res.Attributes);\n        },\n        async deleteSession(sessionToken) {\n            const data = await client.query({\n                TableName,\n                IndexName,\n                KeyConditionExpression: \"#gsi1pk = :gsi1pk AND #gsi1sk = :gsi1sk\",\n                ExpressionAttributeNames: {\n                    \"#gsi1pk\": GSI1PK,\n                    \"#gsi1sk\": GSI1SK,\n                },\n                ExpressionAttributeValues: {\n                    \":gsi1pk\": `SESSION#${sessionToken}`,\n                    \":gsi1sk\": `SESSION#${sessionToken}`,\n                },\n            });\n            if (!data?.Items?.length)\n                return null;\n            const { pk, sk } = data.Items[0];\n            const res = await client.delete({\n                TableName,\n                Key: { pk, sk },\n                ReturnValues: \"ALL_OLD\",\n            });\n            return format.from(res.Attributes);\n        },\n        async createVerificationToken(data) {\n            await client.put({\n                TableName,\n                Item: format.to({\n                    [pk]: `VT#${data.identifier}`,\n                    [sk]: `VT#${data.token}`,\n                    type: \"VT\",\n                    ...data,\n                }),\n            });\n            return data;\n        },\n        async useVerificationToken({ identifier, token }) {\n            const data = await client.delete({\n                TableName,\n                Key: {\n                    [pk]: `VT#${identifier}`,\n                    [sk]: `VT#${token}`,\n                },\n                ReturnValues: \"ALL_OLD\",\n            });\n            return format.from(data.Attributes);\n        },\n    };\n}\n// https://github.com/honeinc/is-iso-date/blob/master/index.js\nconst isoDateRE = /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/;\nfunction isDate(value) {\n    return value && isoDateRE.test(value) && !isNaN(Date.parse(value));\n}\nconst format = {\n    /** Takes a plain old JavaScript object and turns it into a Dynamodb object */\n    to(object) {\n        const newObject = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value instanceof Date) {\n                // DynamoDB requires the TTL attribute be a UNIX timestamp (in secs).\n                if (key === \"expires\")\n                    newObject[key] = value.getTime() / 1000;\n                else\n                    newObject[key] = value.toISOString();\n            }\n            else\n                newObject[key] = value;\n        }\n        return newObject;\n    },\n    /** Takes a Dynamo object and returns a plain old JavaScript object */\n    from(object) {\n        if (!object)\n            return null;\n        const newObject = {};\n        for (const key in object) {\n            // Filter DynamoDB specific attributes so it doesn't get passed to core,\n            // to avoid revealing the type of database\n            if ([\"pk\", \"sk\", \"GSI1PK\", \"GSI1SK\"].includes(key))\n                continue;\n            const value = object[key];\n            if (isDate(value))\n                newObject[key] = new Date(value);\n            // hack to keep type property in account\n            else if (key === \"type\" && [\"SESSION\", \"VT\", \"USER\"].includes(value))\n                continue;\n            // The expires property is stored as a UNIX timestamp in seconds, but\n            // JavaScript needs it in milliseconds, so multiply by 1000.\n            else if (key === \"expires\" && typeof value === \"number\")\n                newObject[key] = new Date(value * 1000);\n            else\n                newObject[key] = value;\n        }\n        return newObject;\n    },\n};\nfunction generateUpdateExpression(object) {\n    const formattedSession = format.to(object);\n    let UpdateExpression = \"set\";\n    const ExpressionAttributeNames = {};\n    const ExpressionAttributeValues = {};\n    for (const property in formattedSession) {\n        UpdateExpression += ` #${property} = :${property},`;\n        ExpressionAttributeNames[\"#\" + property] = property;\n        ExpressionAttributeValues[\":\" + property] = formattedSession[property];\n    }\n    UpdateExpression = UpdateExpression.slice(0, -1);\n    return {\n        UpdateExpression,\n        ExpressionAttributeNames,\n        ExpressionAttributeValues,\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQG5leHQtYXV0aC9keW5hbW9kYi1hZGFwdGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBLGdCQUFnQixxRkFBcUY7QUFDckcsZUFBZSxzQkFBc0I7QUFDckM7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDhCQUE4QjtBQUNqSDtBQUNBO0FBQ0EsWUFBWSxpQ0FBaUM7QUFDN0MsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlEQUFpRDtBQUN0RSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0EsSUFBSTtBQUNKO0FBQ0EscUJBQXFCLHFEQUFxRDtBQUMxRSxnQkFBZ0IscURBQXFEO0FBQ3JFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LGdDQUFnQyxNQUFNO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSx5RUFBeUUsRUFBRSxvRUFBb0UsRUFBRTtBQUMxSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVLEtBQUssU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRhcHBqcy8uL25vZGVfbW9kdWxlcy9AbmV4dC1hdXRoL2R5bmFtb2RiLWFkYXB0ZXIvaW5kZXguanM/OWRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIDxkaXYgc3R5bGU9e3tkaXNwbGF5OiBcImZsZXhcIiwganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLCBwYWRkaW5nOiAxNn19PlxuICogIDxwIHN0eWxlPXt7Zm9udFdlaWdodDogXCJub3JtYWxcIn19Pk9mZmljaWFsIDxhIGhyZWY9XCJodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vYW1hem9uZHluYW1vZGIvbGF0ZXN0L2RldmVsb3Blcmd1aWRlL0ludHJvZHVjdGlvbi5odG1sXCI+RHluYW1vREI8L2E+IGFkYXB0ZXIgZm9yIEF1dGguanMgLyBOZXh0QXV0aC5qcy48L3A+XG4gKiAgPGEgaHJlZj1cImh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9keW5hbW9kYi9pbmRleC5odG1sXCI+XG4gKiAgIDxpbWcgc3R5bGU9e3tkaXNwbGF5OiBcImJsb2NrXCJ9fSBzcmM9XCJodHRwczovL2F1dGhqcy5kZXYvaW1nL2FkYXB0ZXJzL2R5bmFtb2RiLnBuZ1wiIHdpZHRoPVwiNDhcIi8+XG4gKiAgPC9hPlxuICogPC9kaXY+XG4gKlxuICogIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogYGBgYmFzaCBucG0yeWFybjJwbnBtXG4gKiBucG0gaW5zdGFsbCBuZXh0LWF1dGggQG5leHQtYXV0aC9keW5hbW9kYi1hZGFwdGVyXG4gKiBgYGBcbiAqXG4gKiBAbW9kdWxlIEBuZXh0LWF1dGgvZHluYW1vZGItYWRhcHRlclxuICovXG5pbXBvcnQgeyB2NCBhcyB1dWlkIH0gZnJvbSBcInV1aWRcIjtcbi8qKlxuICogIyMgU2V0dXBcbiAqXG4gKiBCeSBkZWZhdWx0LCB0aGUgYWRhcHRlciBleHBlY3RzIGEgdGFibGUgd2l0aCBhIHBhcnRpdGlvbiBrZXkgYHBrYCBhbmQgYSBzb3J0IGtleSBgc2tgLCBhcyB3ZWxsIGFzIGEgZ2xvYmFsIHNlY29uZGFyeSBpbmRleCBuYW1lZCBgR1NJMWAgd2l0aCBgR1NJMVBLYCBhcyBwYXJ0aXRpb24ga2V5IGFuZCBgR1NJMVNLYCBhcyBzb3J0aW5nIGtleS4gVG8gYXV0b21hdGljYWxseSBkZWxldGUgc2Vzc2lvbnMgYW5kIHZlcmlmaWNhdGlvbiByZXF1ZXN0cyBhZnRlciB0aGV5IGV4cGlyZSB1c2luZyBbZHluYW1vZGIgVFRMXShodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vYW1hem9uZHluYW1vZGIvbGF0ZXN0L2RldmVsb3Blcmd1aWRlL1RUTC5odG1sKSB5b3Ugc2hvdWxkIFtlbmFibGUgdGhlIFRUTF0oaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2FtYXpvbmR5bmFtb2RiL2xhdGVzdC9kZXZlbG9wZXJndWlkZS90aW1lLXRvLWxpdmUtdHRsLWhvdy10by5odG1sKSB3aXRoIGF0dHJpYnV0ZSBuYW1lICdleHBpcmVzJy4gWW91IGNhbiBzZXQgd2hhdGV2ZXIgeW91IHdhbnQgYXMgdGhlIHRhYmxlIG5hbWUgYW5kIHRoZSBiaWxsaW5nIG1ldGhvZC5cbiAqIFlvdSBjYW4gZmluZCB0aGUgZnVsbCBzY2hlbWEgaW4gdGhlIHRhYmxlIHN0cnVjdHVyZSBzZWN0aW9uIGJlbG93LlxuICpcbiAqICMjIyBDb25maWd1cmluZyBBdXRoLmpzXG4gKlxuICogWW91IG5lZWQgdG8gcGFzcyBgRHluYW1vREJEb2N1bWVudGAgY2xpZW50IGZyb20gdGhlIG1vZHVsYXIgW2Bhd3Mtc2RrYF0oaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL3Nkay1mb3ItamF2YXNjcmlwdC92My9kZXZlbG9wZXItZ3VpZGUvZHluYW1vZGItZXhhbXBsZS1keW5hbW9kYi11dGlsaXRpZXMuaHRtbCkgdjMgdG8gdGhlIGFkYXB0ZXIuXG4gKiBUaGUgZGVmYXVsdCB0YWJsZSBuYW1lIGlzIGBuZXh0LWF1dGhgLCBidXQgeW91IGNhbiBjdXN0b21pc2UgdGhhdCBieSBwYXNzaW5nIGB7IHRhYmxlTmFtZTogJ3lvdXItdGFibGUtbmFtZScgfWAgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaW4gdGhlIGFkYXB0ZXIuXG4gKlxuICogYGBgamF2YXNjcmlwdCB0aXRsZT1cInBhZ2VzL2FwaS9hdXRoL1suLi5uZXh0YXV0aF0uanNcIlxuICogaW1wb3J0IHsgRHluYW1vREIsIER5bmFtb0RCQ2xpZW50Q29uZmlnIH0gZnJvbSBcIkBhd3Mtc2RrL2NsaWVudC1keW5hbW9kYlwiXG4gKiBpbXBvcnQgeyBEeW5hbW9EQkRvY3VtZW50IH0gZnJvbSBcIkBhd3Mtc2RrL2xpYi1keW5hbW9kYlwiXG4gKiBpbXBvcnQgTmV4dEF1dGggZnJvbSBcIm5leHQtYXV0aFwiO1xuICogaW1wb3J0IFByb3ZpZGVycyBmcm9tIFwibmV4dC1hdXRoL3Byb3ZpZGVyc1wiO1xuICogaW1wb3J0IHsgRHluYW1vREJBZGFwdGVyIH0gZnJvbSBcIkBuZXh0LWF1dGgvZHluYW1vZGItYWRhcHRlclwiXG4gKlxuICogY29uc3QgY29uZmlnOiBEeW5hbW9EQkNsaWVudENvbmZpZyA9IHtcbiAqICAgY3JlZGVudGlhbHM6IHtcbiAqICAgICBhY2Nlc3NLZXlJZDogcHJvY2Vzcy5lbnYuTkVYVF9BVVRIX0FXU19BQ0NFU1NfS0VZIGFzIHN0cmluZyxcbiAqICAgICBzZWNyZXRBY2Nlc3NLZXk6IHByb2Nlc3MuZW52Lk5FWFRfQVVUSF9BV1NfU0VDUkVUX0tFWSBhcyBzdHJpbmcsXG4gKiAgIH0sXG4gKiAgIHJlZ2lvbjogcHJvY2Vzcy5lbnYuTkVYVF9BVVRIX0FXU19SRUdJT04sXG4gKiB9O1xuICpcbiAqIGNvbnN0IGNsaWVudCA9IER5bmFtb0RCRG9jdW1lbnQuZnJvbShuZXcgRHluYW1vREIoY29uZmlnKSwge1xuICogICBtYXJzaGFsbE9wdGlvbnM6IHtcbiAqICAgICBjb252ZXJ0RW1wdHlWYWx1ZXM6IHRydWUsXG4gKiAgICAgcmVtb3ZlVW5kZWZpbmVkVmFsdWVzOiB0cnVlLFxuICogICAgIGNvbnZlcnRDbGFzc0luc3RhbmNlVG9NYXA6IHRydWUsXG4gKiAgIH0sXG4gKiB9KVxuICpcbiAqIGV4cG9ydCBkZWZhdWx0IE5leHRBdXRoKHtcbiAqICAgLy8gQ29uZmlndXJlIG9uZSBvciBtb3JlIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyc1xuICogICBwcm92aWRlcnM6IFtcbiAqICAgICBQcm92aWRlcnMuR2l0SHViKHtcbiAqICAgICAgIGNsaWVudElkOiBwcm9jZXNzLmVudi5HSVRIVUJfSUQsXG4gKiAgICAgICBjbGllbnRTZWNyZXQ6IHByb2Nlc3MuZW52LkdJVEhVQl9TRUNSRVQsXG4gKiAgICAgfSksXG4gKiAgICAgUHJvdmlkZXJzLkVtYWlsKHtcbiAqICAgICAgIHNlcnZlcjogcHJvY2Vzcy5lbnYuRU1BSUxfU0VSVkVSLFxuICogICAgICAgZnJvbTogcHJvY2Vzcy5lbnYuRU1BSUxfRlJPTSxcbiAqICAgICB9KSxcbiAqICAgICAvLyAuLi5hZGQgbW9yZSBwcm92aWRlcnMgaGVyZVxuICogICBdLFxuICogICBhZGFwdGVyOiBEeW5hbW9EQkFkYXB0ZXIoXG4gKiAgICAgY2xpZW50XG4gKiAgICksXG4gKiAgIC4uLlxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAoQVdTIHNlY3JldHMgc3RhcnQgd2l0aCBgTkVYVF9BVVRIX2AgaW4gb3JkZXIgdG8gbm90IGNvbmZsaWN0IHdpdGggW1ZlcmNlbCdzIHJlc2VydmVkIGVudmlyb25tZW50IHZhcmlhYmxlc10oaHR0cHM6Ly92ZXJjZWwuY29tL2RvY3MvZW52aXJvbm1lbnQtdmFyaWFibGVzI3Jlc2VydmVkLWVudmlyb25tZW50LXZhcmlhYmxlcykuKVxuICpcbiAqICMjIEFkdmFuY2VkIHVzYWdlXG4gKlxuICogIyMjIERlZmF1bHQgc2NoZW1hXG4gKlxuICogVGhlIHRhYmxlIHJlc3BlY3RzIHRoZSBzaW5nbGUgdGFibGUgZGVzaWduIHBhdHRlcm4uIFRoaXMgaGFzIG1hbnkgYWR2YW50YWdlczpcbiAqXG4gKiAtIE9ubHkgb25lIHRhYmxlIHRvIG1hbmFnZSwgbW9uaXRvciBhbmQgcHJvdmlzaW9uLlxuICogLSBRdWVyeWluZyByZWxhdGlvbnMgaXMgZmFzdGVyIHRoYW4gd2l0aCBtdWx0aS10YWJsZSBzY2hlbWFzIChmb3IgZWcuIHJldHJpZXZpbmcgYWxsIHNlc3Npb25zIGZvciBhIHVzZXIpLlxuICogLSBPbmx5IG9uZSB0YWJsZSBuZWVkcyB0byBiZSByZXBsaWNhdGVkIGlmIHlvdSB3YW50IHRvIGdvIG11bHRpLXJlZ2lvbi5cbiAqXG4gKiA+IFRoaXMgc2NoZW1hIGlzIGFkYXB0ZWQgZm9yIHVzZSBpbiBEeW5hbW9EQiBhbmQgYmFzZWQgdXBvbiBvdXIgbWFpbiBbc2NoZW1hXShodHRwczovL2F1dGhqcy5kZXYvcmVmZXJlbmNlL2FkYXB0ZXJzI21vZGVscylcbiAqXG4gKiAhW0R5bmFtb0RCIFRhYmxlXShodHRwczovL2kuaW1ndXIuY29tL2hHWnRXRHEucG5nKVxuICpcbiAqIFlvdSBjYW4gY3JlYXRlIHRoaXMgdGFibGUgd2l0aCBpbmZyYXN0cnVjdHVyZSBhcyBjb2RlIHVzaW5nIFtgYXdzLWNka2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkaykgd2l0aCB0aGUgZm9sbG93aW5nIHRhYmxlIGRlZmluaXRpb246XG4gKlxuICogYGBgamF2YXNjcmlwdCB0aXRsZT1zdGFjay50c1xuICogbmV3IGR5bmFtb2RiLlRhYmxlKHRoaXMsIGBOZXh0QXV0aFRhYmxlYCwge1xuICogICB0YWJsZU5hbWU6IFwibmV4dC1hdXRoXCIsXG4gKiAgIHBhcnRpdGlvbktleTogeyBuYW1lOiBcInBrXCIsIHR5cGU6IGR5bmFtb2RiLkF0dHJpYnV0ZVR5cGUuU1RSSU5HIH0sXG4gKiAgIHNvcnRLZXk6IHsgbmFtZTogXCJza1wiLCB0eXBlOiBkeW5hbW9kYi5BdHRyaWJ1dGVUeXBlLlNUUklORyB9LFxuICogICB0aW1lVG9MaXZlQXR0cmlidXRlOiBcImV4cGlyZXNcIixcbiAqIH0pLmFkZEdsb2JhbFNlY29uZGFyeUluZGV4KHtcbiAqICAgaW5kZXhOYW1lOiBcIkdTSTFcIixcbiAqICAgcGFydGl0aW9uS2V5OiB7IG5hbWU6IFwiR1NJMVBLXCIsIHR5cGU6IGR5bmFtb2RiLkF0dHJpYnV0ZVR5cGUuU1RSSU5HIH0sXG4gKiAgIHNvcnRLZXk6IHsgbmFtZTogXCJHU0kxU0tcIiwgdHlwZTogZHluYW1vZGIuQXR0cmlidXRlVHlwZS5TVFJJTkcgfSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHVzZSB0aGlzIGNsb3VkZm9ybWF0aW9uIHRlbXBsYXRlOlxuICpcbiAqIGBgYHlhbWwgdGl0bGU9Y2xvdWRmb3JtYXRpb24ueWFtbFxuICogTmV4dEF1dGhUYWJsZTpcbiAqICAgVHlwZTogXCJBV1M6OkR5bmFtb0RCOjpUYWJsZVwiXG4gKiAgIFByb3BlcnRpZXM6XG4gKiAgICAgVGFibGVOYW1lOiBuZXh0LWF1dGhcbiAqICAgICBBdHRyaWJ1dGVEZWZpbml0aW9uczpcbiAqICAgICAgIC0gQXR0cmlidXRlTmFtZTogcGtcbiAqICAgICAgICAgQXR0cmlidXRlVHlwZTogU1xuICogICAgICAgLSBBdHRyaWJ1dGVOYW1lOiBza1xuICogICAgICAgICBBdHRyaWJ1dGVUeXBlOiBTXG4gKiAgICAgICAtIEF0dHJpYnV0ZU5hbWU6IEdTSTFQS1xuICogICAgICAgICBBdHRyaWJ1dGVUeXBlOiBTXG4gKiAgICAgICAtIEF0dHJpYnV0ZU5hbWU6IEdTSTFTS1xuICogICAgICAgICBBdHRyaWJ1dGVUeXBlOiBTXG4gKiAgICAgS2V5U2NoZW1hOlxuICogICAgICAgLSBBdHRyaWJ1dGVOYW1lOiBwa1xuICogICAgICAgICBLZXlUeXBlOiBIQVNIXG4gKiAgICAgICAtIEF0dHJpYnV0ZU5hbWU6IHNrXG4gKiAgICAgICAgIEtleVR5cGU6IFJBTkdFXG4gKiAgICAgR2xvYmFsU2Vjb25kYXJ5SW5kZXhlczpcbiAqICAgICAgIC0gSW5kZXhOYW1lOiBHU0kxXG4gKiAgICAgICAgIFByb2plY3Rpb246XG4gKiAgICAgICAgICAgUHJvamVjdGlvblR5cGU6IEFMTFxuICogICAgICAgICBLZXlTY2hlbWE6XG4gKiAgICAgICAgICAgLSBBdHRyaWJ1dGVOYW1lOiBHU0kxUEtcbiAqICAgICAgICAgICAgIEtleVR5cGU6IEhBU0hcbiAqICAgICAgICAgICAtIEF0dHJpYnV0ZU5hbWU6IEdTSTFTS1xuICogICAgICAgICAgICAgS2V5VHlwZTogUkFOR0VcbiAqICAgICBUaW1lVG9MaXZlU3BlY2lmaWNhdGlvbjpcbiAqICAgICAgIEF0dHJpYnV0ZU5hbWU6IGV4cGlyZXNcbiAqICAgICAgIEVuYWJsZWQ6IHRydWVcbiAqIGBgYFxuICpcbiAqICMjIyBVc2luZyBhIGN1c3RvbSBzY2hlbWFcbiAqXG4gKiBZb3UgY2FuIGNvbmZpZ3VyZSB5b3VyIGN1c3RvbSB0YWJsZSBzY2hlbWEgYnkgcGFzc2luZyB0aGUgYG9wdGlvbnNgIGtleSB0byB0aGUgYWRhcHRlciBjb25zdHJ1Y3RvcjpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCBhZGFwdGVyID0gRHluYW1vREJBZGFwdGVyKGNsaWVudCwge1xuICogICB0YWJsZU5hbWU6IFwiY3VzdG9tLXRhYmxlLW5hbWVcIixcbiAqICAgcGFydGl0aW9uS2V5OiBcImN1c3RvbS1wa1wiLFxuICogICBzb3J0S2V5OiBcImN1c3RvbS1za1wiLFxuICogICBpbmRleE5hbWU6IFwiY3VzdG9tLWluZGV4LW5hbWVcIixcbiAqICAgaW5kZXhQYXJ0aXRpb25LZXk6IFwiY3VzdG9tLWluZGV4LXBrXCIsXG4gKiAgIGluZGV4U29ydEtleTogXCJjdXN0b20taW5kZXgtc2tcIixcbiAqIH0pXG4gKiBgYGBcbiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBEeW5hbW9EQkFkYXB0ZXIoY2xpZW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgVGFibGVOYW1lID0gb3B0aW9ucz8udGFibGVOYW1lID8/IFwibmV4dC1hdXRoXCI7XG4gICAgY29uc3QgcGsgPSBvcHRpb25zPy5wYXJ0aXRpb25LZXkgPz8gXCJwa1wiO1xuICAgIGNvbnN0IHNrID0gb3B0aW9ucz8uc29ydEtleSA/PyBcInNrXCI7XG4gICAgY29uc3QgSW5kZXhOYW1lID0gb3B0aW9ucz8uaW5kZXhOYW1lID8/IFwiR1NJMVwiO1xuICAgIGNvbnN0IEdTSTFQSyA9IG9wdGlvbnM/LmluZGV4UGFydGl0aW9uS2V5ID8/IFwiR1NJMVBLXCI7XG4gICAgY29uc3QgR1NJMVNLID0gb3B0aW9ucz8uaW5kZXhTb3J0S2V5ID8/IFwiR1NJMVNLXCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgY3JlYXRlVXNlcihkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0ge1xuICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgaWQ6IHV1aWQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucHV0KHtcbiAgICAgICAgICAgICAgICBUYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgSXRlbTogZm9ybWF0LnRvKHtcbiAgICAgICAgICAgICAgICAgICAgLi4udXNlcixcbiAgICAgICAgICAgICAgICAgICAgW3BrXTogYFVTRVIjJHt1c2VyLmlkfWAsXG4gICAgICAgICAgICAgICAgICAgIFtza106IGBVU0VSIyR7dXNlci5pZH1gLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlVTRVJcIixcbiAgICAgICAgICAgICAgICAgICAgW0dTSTFQS106IGBVU0VSIyR7dXNlci5lbWFpbH1gLFxuICAgICAgICAgICAgICAgICAgICBbR1NJMVNLXTogYFVTRVIjJHt1c2VyLmVtYWlsfWAsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB1c2VyO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRVc2VyKHVzZXJJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNsaWVudC5nZXQoe1xuICAgICAgICAgICAgICAgIFRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgW3BrXTogYFVTRVIjJHt1c2VySWR9YCxcbiAgICAgICAgICAgICAgICAgICAgW3NrXTogYFVTRVIjJHt1c2VySWR9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0LmZyb20oZGF0YS5JdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0VXNlckJ5RW1haWwoZW1haWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjbGllbnQucXVlcnkoe1xuICAgICAgICAgICAgICAgIFRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBJbmRleE5hbWUsXG4gICAgICAgICAgICAgICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogXCIjZ3NpMXBrID0gOmdzaTFwayBBTkQgI2dzaTFzayA9IDpnc2kxc2tcIixcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIjZ3NpMXBrXCI6IEdTSTFQSyxcbiAgICAgICAgICAgICAgICAgICAgXCIjZ3NpMXNrXCI6IEdTSTFTSyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCI6Z3NpMXBrXCI6IGBVU0VSIyR7ZW1haWx9YCxcbiAgICAgICAgICAgICAgICAgICAgXCI6Z3NpMXNrXCI6IGBVU0VSIyR7ZW1haWx9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0LmZyb20oZGF0YS5JdGVtcz8uWzBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZ2V0VXNlckJ5QWNjb3VudCh7IHByb3ZpZGVyLCBwcm92aWRlckFjY291bnRJZCB9KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2xpZW50LnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBUYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgSW5kZXhOYW1lLFxuICAgICAgICAgICAgICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246IFwiI2dzaTFwayA9IDpnc2kxcGsgQU5EICNnc2kxc2sgPSA6Z3NpMXNrXCIsXG4gICAgICAgICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiI2dzaTFwa1wiOiBHU0kxUEssXG4gICAgICAgICAgICAgICAgICAgIFwiI2dzaTFza1wiOiBHU0kxU0ssXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiOmdzaTFwa1wiOiBgQUNDT1VOVCMke3Byb3ZpZGVyfWAsXG4gICAgICAgICAgICAgICAgICAgIFwiOmdzaTFza1wiOiBgQUNDT1VOVCMke3Byb3ZpZGVyQWNjb3VudElkfWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFkYXRhLkl0ZW1zPy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IGRhdGEuSXRlbXNbMF07XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQuZ2V0KHtcbiAgICAgICAgICAgICAgICBUYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgS2V5OiB7XG4gICAgICAgICAgICAgICAgICAgIFtwa106IGBVU0VSIyR7YWNjb3VudHMudXNlcklkfWAsXG4gICAgICAgICAgICAgICAgICAgIFtza106IGBVU0VSIyR7YWNjb3VudHMudXNlcklkfWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5mcm9tKHJlcy5JdGVtKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdXBkYXRlVXNlcih1c2VyKSB7XG4gICAgICAgICAgICBjb25zdCB7IFVwZGF0ZUV4cHJlc3Npb24sIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcywgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcywgfSA9IGdlbmVyYXRlVXBkYXRlRXhwcmVzc2lvbih1c2VyKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjbGllbnQudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBUYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgS2V5OiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5leHQtYXV0aCB0eXBlIGlzIGluY29ycmVjdCBpdCBzaG91bGQgYmUgUGFydGlhbDxBZGFwdGVyVXNlcj4gJiB7aWQ6IHN0cmluZ30gaW5zdGVhZCBvZiBqdXN0IFBhcnRpYWw8QWRhcHRlclVzZXI+XG4gICAgICAgICAgICAgICAgICAgIFtwa106IGBVU0VSIyR7dXNlci5pZH1gLFxuICAgICAgICAgICAgICAgICAgICBbc2tdOiBgVVNFUiMke3VzZXIuaWR9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFVwZGF0ZUV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXMsXG4gICAgICAgICAgICAgICAgUmV0dXJuVmFsdWVzOiBcIkFMTF9ORVdcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQuZnJvbShkYXRhLkF0dHJpYnV0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBkZWxldGVVc2VyKHVzZXJJZCkge1xuICAgICAgICAgICAgLy8gcXVlcnkgYWxsIHRoZSBpdGVtcyByZWxhdGVkIHRvIHRoZSB1c2VyIHRvIGRlbGV0ZVxuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBUYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogXCIjcGsgPSA6cGtcIixcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHsgXCIjcGtcIjogcGsgfSxcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7IFwiOnBrXCI6IGBVU0VSIyR7dXNlcklkfWAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXMuSXRlbXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHJlcy5JdGVtcztcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHVzZXIgd2Ugd2FudCB0byBkZWxldGUgdG8gcmV0dXJuIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBpdGVtcy5maW5kKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09IFwiVVNFUlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zVG9EZWxldGUgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBEZWxldGVSZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2tdOiBpdGVtLnNrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtwa106IGl0ZW0ucGssXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGJhdGNoIHdyaXRlIGNvbW1hbmRzIGNhbm5vdCBoYW5kbGUgbW9yZSB0aGFuIDI1IHJlcXVlc3RzIGF0IG9uY2VcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zVG9EZWxldGVNYXggPSBpdGVtc1RvRGVsZXRlLnNsaWNlKDAsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0ge1xuICAgICAgICAgICAgICAgIFJlcXVlc3RJdGVtczogeyBbVGFibGVOYW1lXTogaXRlbXNUb0RlbGV0ZU1heCB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5iYXRjaFdyaXRlKHBhcmFtKTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQuZnJvbSh1c2VyKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgbGlua0FjY291bnQoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgICAgIGlkOiB1dWlkKCksXG4gICAgICAgICAgICAgICAgW3BrXTogYFVTRVIjJHtkYXRhLnVzZXJJZH1gLFxuICAgICAgICAgICAgICAgIFtza106IGBBQ0NPVU5UIyR7ZGF0YS5wcm92aWRlcn0jJHtkYXRhLnByb3ZpZGVyQWNjb3VudElkfWAsXG4gICAgICAgICAgICAgICAgW0dTSTFQS106IGBBQ0NPVU5UIyR7ZGF0YS5wcm92aWRlcn1gLFxuICAgICAgICAgICAgICAgIFtHU0kxU0tdOiBgQUNDT1VOVCMke2RhdGEucHJvdmlkZXJBY2NvdW50SWR9YCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdCBjbGllbnQucHV0KHsgVGFibGVOYW1lLCBJdGVtOiBmb3JtYXQudG8oaXRlbSkgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdW5saW5rQWNjb3VudCh7IHByb3ZpZGVyLCBwcm92aWRlckFjY291bnRJZCB9KSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2xpZW50LnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBUYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgSW5kZXhOYW1lLFxuICAgICAgICAgICAgICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246IFwiI2dzaTFwayA9IDpnc2kxcGsgQU5EICNnc2kxc2sgPSA6Z3NpMXNrXCIsXG4gICAgICAgICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiI2dzaTFwa1wiOiBHU0kxUEssXG4gICAgICAgICAgICAgICAgICAgIFwiI2dzaTFza1wiOiBHU0kxU0ssXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiOmdzaTFwa1wiOiBgQUNDT1VOVCMke3Byb3ZpZGVyfWAsXG4gICAgICAgICAgICAgICAgICAgIFwiOmdzaTFza1wiOiBgQUNDT1VOVCMke3Byb3ZpZGVyQWNjb3VudElkfWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IGZvcm1hdC5mcm9tKGRhdGEuSXRlbXM/LlswXSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LmRlbGV0ZSh7XG4gICAgICAgICAgICAgICAgVGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIEtleToge1xuICAgICAgICAgICAgICAgICAgICBbcGtdOiBgVVNFUiMke2FjY291bnQudXNlcklkfWAsXG4gICAgICAgICAgICAgICAgICAgIFtza106IGBBQ0NPVU5UIyR7cHJvdmlkZXJ9IyR7cHJvdmlkZXJBY2NvdW50SWR9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFJldHVyblZhbHVlczogXCJBTExfT0xEXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50O1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBnZXRTZXNzaW9uQW5kVXNlcihzZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjbGllbnQucXVlcnkoe1xuICAgICAgICAgICAgICAgIFRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBJbmRleE5hbWUsXG4gICAgICAgICAgICAgICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbjogXCIjZ3NpMXBrID0gOmdzaTFwayBBTkQgI2dzaTFzayA9IDpnc2kxc2tcIixcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCIjZ3NpMXBrXCI6IEdTSTFQSyxcbiAgICAgICAgICAgICAgICAgICAgXCIjZ3NpMXNrXCI6IEdTSTFTSyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCI6Z3NpMXBrXCI6IGBTRVNTSU9OIyR7c2Vzc2lvblRva2VufWAsXG4gICAgICAgICAgICAgICAgICAgIFwiOmdzaTFza1wiOiBgU0VTU0lPTiMke3Nlc3Npb25Ub2tlbn1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBmb3JtYXQuZnJvbShkYXRhLkl0ZW1zPy5bMF0pO1xuICAgICAgICAgICAgaWYgKCFzZXNzaW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LmdldCh7XG4gICAgICAgICAgICAgICAgVGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIEtleToge1xuICAgICAgICAgICAgICAgICAgICBbcGtdOiBgVVNFUiMke3Nlc3Npb24udXNlcklkfWAsXG4gICAgICAgICAgICAgICAgICAgIFtza106IGBVU0VSIyR7c2Vzc2lvbi51c2VySWR9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZm9ybWF0LmZyb20ocmVzLkl0ZW0pO1xuICAgICAgICAgICAgaWYgKCF1c2VyKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHsgdXNlciwgc2Vzc2lvbiB9O1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBjcmVhdGVTZXNzaW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHV1aWQoKSxcbiAgICAgICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0IGNsaWVudC5wdXQoe1xuICAgICAgICAgICAgICAgIFRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBJdGVtOiBmb3JtYXQudG8oe1xuICAgICAgICAgICAgICAgICAgICBbcGtdOiBgVVNFUiMke2RhdGEudXNlcklkfWAsXG4gICAgICAgICAgICAgICAgICAgIFtza106IGBTRVNTSU9OIyR7ZGF0YS5zZXNzaW9uVG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgW0dTSTFTS106IGBTRVNTSU9OIyR7ZGF0YS5zZXNzaW9uVG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgW0dTSTFQS106IGBTRVNTSU9OIyR7ZGF0YS5zZXNzaW9uVG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJTRVNTSU9OXCIsXG4gICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyB1cGRhdGVTZXNzaW9uKHNlc3Npb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvblRva2VuIH0gPSBzZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNsaWVudC5xdWVyeSh7XG4gICAgICAgICAgICAgICAgVGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIEluZGV4TmFtZSxcbiAgICAgICAgICAgICAgICBLZXlDb25kaXRpb25FeHByZXNzaW9uOiBcIiNnc2kxcGsgPSA6Z3NpMXBrIEFORCAjZ3NpMXNrID0gOmdzaTFza1wiLFxuICAgICAgICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lczoge1xuICAgICAgICAgICAgICAgICAgICBcIiNnc2kxcGtcIjogR1NJMVBLLFxuICAgICAgICAgICAgICAgICAgICBcIiNnc2kxc2tcIjogR1NJMVNLLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgICAgICAgICAgICAgICBcIjpnc2kxcGtcIjogYFNFU1NJT04jJHtzZXNzaW9uVG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgXCI6Z3NpMXNrXCI6IGBTRVNTSU9OIyR7c2Vzc2lvblRva2VufWAsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFkYXRhLkl0ZW1zPy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHBrLCBzayB9ID0gZGF0YS5JdGVtc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHsgVXBkYXRlRXhwcmVzc2lvbiwgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLCBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLCB9ID0gZ2VuZXJhdGVVcGRhdGVFeHByZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgY2xpZW50LnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgVGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIEtleTogeyBwaywgc2sgfSxcbiAgICAgICAgICAgICAgICBVcGRhdGVFeHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgICAgICAgICAgICAgIFJldHVyblZhbHVlczogXCJBTExfTkVXXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQuZnJvbShyZXMuQXR0cmlidXRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIGRlbGV0ZVNlc3Npb24oc2Vzc2lvblRva2VuKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgY2xpZW50LnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICBUYWJsZU5hbWUsXG4gICAgICAgICAgICAgICAgSW5kZXhOYW1lLFxuICAgICAgICAgICAgICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246IFwiI2dzaTFwayA9IDpnc2kxcGsgQU5EICNnc2kxc2sgPSA6Z3NpMXNrXCIsXG4gICAgICAgICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiI2dzaTFwa1wiOiBHU0kxUEssXG4gICAgICAgICAgICAgICAgICAgIFwiI2dzaTFza1wiOiBHU0kxU0ssXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiOmdzaTFwa1wiOiBgU0VTU0lPTiMke3Nlc3Npb25Ub2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICBcIjpnc2kxc2tcIjogYFNFU1NJT04jJHtzZXNzaW9uVG9rZW59YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWRhdGE/Lkl0ZW1zPy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHBrLCBzayB9ID0gZGF0YS5JdGVtc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGNsaWVudC5kZWxldGUoe1xuICAgICAgICAgICAgICAgIFRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBLZXk6IHsgcGssIHNrIH0sXG4gICAgICAgICAgICAgICAgUmV0dXJuVmFsdWVzOiBcIkFMTF9PTERcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5mcm9tKHJlcy5BdHRyaWJ1dGVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgY3JlYXRlVmVyaWZpY2F0aW9uVG9rZW4oZGF0YSkge1xuICAgICAgICAgICAgYXdhaXQgY2xpZW50LnB1dCh7XG4gICAgICAgICAgICAgICAgVGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIEl0ZW06IGZvcm1hdC50byh7XG4gICAgICAgICAgICAgICAgICAgIFtwa106IGBWVCMke2RhdGEuaWRlbnRpZmllcn1gLFxuICAgICAgICAgICAgICAgICAgICBbc2tdOiBgVlQjJHtkYXRhLnRva2VufWAsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiVlRcIixcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIGFzeW5jIHVzZVZlcmlmaWNhdGlvblRva2VuKHsgaWRlbnRpZmllciwgdG9rZW4gfSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGNsaWVudC5kZWxldGUoe1xuICAgICAgICAgICAgICAgIFRhYmxlTmFtZSxcbiAgICAgICAgICAgICAgICBLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgW3BrXTogYFZUIyR7aWRlbnRpZmllcn1gLFxuICAgICAgICAgICAgICAgICAgICBbc2tdOiBgVlQjJHt0b2tlbn1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgUmV0dXJuVmFsdWVzOiBcIkFMTF9PTERcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdC5mcm9tKGRhdGEuQXR0cmlidXRlcyk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ob25laW5jL2lzLWlzby1kYXRlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5jb25zdCBpc29EYXRlUkUgPSAvKFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkKyhbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpLztcbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiBpc29EYXRlUkUudGVzdCh2YWx1ZSkgJiYgIWlzTmFOKERhdGUucGFyc2UodmFsdWUpKTtcbn1cbmNvbnN0IGZvcm1hdCA9IHtcbiAgICAvKiogVGFrZXMgYSBwbGFpbiBvbGQgSmF2YVNjcmlwdCBvYmplY3QgYW5kIHR1cm5zIGl0IGludG8gYSBEeW5hbW9kYiBvYmplY3QgKi9cbiAgICB0byhvYmplY3QpIHtcbiAgICAgICAgY29uc3QgbmV3T2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBEeW5hbW9EQiByZXF1aXJlcyB0aGUgVFRMIGF0dHJpYnV0ZSBiZSBhIFVOSVggdGltZXN0YW1wIChpbiBzZWNzKS5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImV4cGlyZXNcIilcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSB2YWx1ZS5nZXRUaW1lKCkgLyAxMDAwO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSB2YWx1ZS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5ld09iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iamVjdDtcbiAgICB9LFxuICAgIC8qKiBUYWtlcyBhIER5bmFtbyBvYmplY3QgYW5kIHJldHVybnMgYSBwbGFpbiBvbGQgSmF2YVNjcmlwdCBvYmplY3QgKi9cbiAgICBmcm9tKG9iamVjdCkge1xuICAgICAgICBpZiAoIW9iamVjdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBuZXdPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgRHluYW1vREIgc3BlY2lmaWMgYXR0cmlidXRlcyBzbyBpdCBkb2Vzbid0IGdldCBwYXNzZWQgdG8gY29yZSxcbiAgICAgICAgICAgIC8vIHRvIGF2b2lkIHJldmVhbGluZyB0aGUgdHlwZSBvZiBkYXRhYmFzZVxuICAgICAgICAgICAgaWYgKFtcInBrXCIsIFwic2tcIiwgXCJHU0kxUEtcIiwgXCJHU0kxU0tcIl0uaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAoaXNEYXRlKHZhbHVlKSlcbiAgICAgICAgICAgICAgICBuZXdPYmplY3Rba2V5XSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIGhhY2sgdG8ga2VlcCB0eXBlIHByb3BlcnR5IGluIGFjY291bnRcbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJ0eXBlXCIgJiYgW1wiU0VTU0lPTlwiLCBcIlZUXCIsIFwiVVNFUlwiXS5pbmNsdWRlcyh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBUaGUgZXhwaXJlcyBwcm9wZXJ0eSBpcyBzdG9yZWQgYXMgYSBVTklYIHRpbWVzdGFtcCBpbiBzZWNvbmRzLCBidXRcbiAgICAgICAgICAgIC8vIEphdmFTY3JpcHQgbmVlZHMgaXQgaW4gbWlsbGlzZWNvbmRzLCBzbyBtdWx0aXBseSBieSAxMDAwLlxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImV4cGlyZXNcIiAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSBuZXcgRGF0ZSh2YWx1ZSAqIDEwMDApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG5ld09iamVjdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld09iamVjdDtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGdlbmVyYXRlVXBkYXRlRXhwcmVzc2lvbihvYmplY3QpIHtcbiAgICBjb25zdCBmb3JtYXR0ZWRTZXNzaW9uID0gZm9ybWF0LnRvKG9iamVjdCk7XG4gICAgbGV0IFVwZGF0ZUV4cHJlc3Npb24gPSBcInNldFwiO1xuICAgIGNvbnN0IEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyA9IHt9O1xuICAgIGNvbnN0IEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIGZvcm1hdHRlZFNlc3Npb24pIHtcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbiArPSBgICMke3Byb3BlcnR5fSA9IDoke3Byb3BlcnR5fSxgO1xuICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXNbXCIjXCIgKyBwcm9wZXJ0eV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlc1tcIjpcIiArIHByb3BlcnR5XSA9IGZvcm1hdHRlZFNlc3Npb25bcHJvcGVydHldO1xuICAgIH1cbiAgICBVcGRhdGVFeHByZXNzaW9uID0gVXBkYXRlRXhwcmVzc2lvbi5zbGljZSgwLCAtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgVXBkYXRlRXhwcmVzc2lvbixcbiAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgIH07XG59XG5leHBvcnQgeyBmb3JtYXQsIGdlbmVyYXRlVXBkYXRlRXhwcmVzc2lvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@next-auth/dynamodb-adapter/index.js\n");

/***/ })

};
;